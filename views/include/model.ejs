<script>
var colors = [
	"#807c59",
	"#618059",
	"#73bf60",
	"#ccae8f",
	"#806c59",
	"#bf9060",
	"#65567a",
	"#8860bf",
	"#bfb660",
	"#cc8f8f",
	"#bf6060"
];

var viewModel = {
	view: ko.observable('list'),
	organization: ko.observable(),
	organizations: ko.observableArray(<%- JSON.stringify(user.organizations) %>),
	loading: ko.observable(false),
	repos: ko.observableArray(),
	pushes: ko.observableArray(),
	startDate: ko.observable(),
	endDate: ko.observable(),
	filter: ko.observable(),

	getGithubCompareLink: function (push) {
		return 'https://github.com/' + [push.repo.name, 'compare', push.before + '...' + push.head].join('/');
	},
	getPushCommits: function (push) {
		var messages = _.map(_.pluck(push.commits, 'message'), function (msg) {
			return 'â€£ ' + msg;
		});
		return messages.join('\n');
	},
	getPushTime: function (push) {
		return moment(push.date).fromNow(true);
	},
	getPushTooltip: function (push) {
		return this.getPushTime(push) + '\n' + this.getPushCommits(push);
	},
	getSimpleRepoName: function (name) {
		var organization = this.organization();
		if (organization && name && name.indexOf(organization.login + '/') === 0) {
			return name.substr(organization.login.length + 1);
		}
		return name;
	},
	setFilter: function (data, event) {
		if (event.target.className === 'repo-tag') {
			viewModel.filter(function (push) { return push.repo.name === data.repo.name; });
		} else if (event.target.className === 'push-user') {
			viewModel.filter(function (push) { return push.user.login === data.user.login; });
		} else {
			viewModel.filter(null);
		}
	},
	bucketize: function (pushes) {
		var max = _.last(this.pushes());
		max = max ? max.bucket : 0;

		var result = [];
		while (result.length <= max) {
			result.push({
				bucket: result.length,
				bucketClass: 'bucket-' + result.length + ' bucket-color-' + result.length % colors.length,
				pushes: []
			});
		}

		pushes.forEach(function (push) {
			result[push.bucket].pushes.push(push);
		});
		result.forEach(function (bucket) {
			if (bucket.pushes.length === 0) {
				bucket.bucketClass += ' empty';
			}
		});
		return result;
	},
	adjustAllLanes: _.debounce(function () {
		var adjusts = 0;
		var overlap = 5;

		function bump(node, amount) {
			var previous = parseInt(node.style.marginTop, 10) || 0;
			node.style.marginTop = previous + amount + "px";
		}

		underlay.clear();

		for (var bucket = 0; ; bucket++) {

			// TODO do all the math in memory, then dump it into the DOM when finished
			var row = document.querySelectorAll('.pushes.bucket-' + bucket)
			if (!row.length) break;

			for (var c = 0; c < row.length; c++) {
				if (adjusts++ > 5000) {
					console.log('too many layout iterations, aborting');
					return;
				}

				var current = row[c];
				var previous = row[c - 1];

				if (previous) {
					var pt = previous.offsetTop;
					var pb = pt + previous.offsetHeight;

					var ct = current.offsetTop;
					var cb = ct + current.offsetHeight;

					if (ct > (pb - overlap)) {
						// bump previous, recursively
//						console.log('bump (previous)', previous);
						bump(previous, ct - pb + overlap);
						c -= 2;
					} else if (cb < (pt + overlap)) {
						// bump current, no recursion
//						console.log('bump (current)', current);
						bump(current, pt - cb + overlap);
					}
				}
			}

			var els = _.map(row, function (e) {
				var overlap = 0;
				var xmin = e.offsetLeft + overlap;
				var xmax = e.offsetLeft + e.offsetWidth - overlap;
				var xbar = e.offsetLeft + e.offsetWidth / 2;
				var ymin = e.offsetTop + overlap;
				var ymax = e.offsetTop + e.offsetHeight - overlap;
				var ybar = e.offsetTop + e.offsetHeight / 2;
				return { xmin: xmin, xmax: xmax, xbar: xbar, ymin: ymin, ymax: ymax, ybar: ybar };
			});

			function smooth(els, y1, y2) {
				var tops = [];
				for (var i = 0; i < els.length; i++) {
					var e = els[i];
					var ne = els[i + 1];
					if (i == 0) {
						if (y2) {
							tops.push('M' + e.xbar + ',' + e[y1]);
						} else {
							tops.push('M' + e.xmin + ',' + e[y1]);
							tops.push('L' + e.xbar + ',' + e[y1]);
						}
					}
					if (ne) {
						tops.push('C' + e.xmax + ',' + e[y1] + ' ' + ne.xmin + ',' + ne[y1] + ' ' + ne.xbar + ',' + ne[y1]);
					} else {
						if (y2) {
							tops.push('C' + e.xmax + ',' + e[y1] + ' ' + e.xmax + ',' + e[y2] + ' ' + e.xbar + ',' + e[y2]);
						} else {
							tops.push('L' + e.xmax + ',' + e[y1]);
						}
					}
				}
				if (y2) {
					for (var i = els.length - 1; i >= 0; i--) {
						var e = els[i];
						var ne = els[i - 1];
						if (ne) {
							tops.push('C' + e.xmin + ',' + e[y2] + ' ' + ne.xmax + ',' + ne[y2] + ' ' + ne.xbar + ',' + ne[y2]);
						} else {
							tops.push('C' + e.xmin + ',' + e[y2] + ' ' + e.xmin + ',' + e[y1] + ' ' + e.xbar + ',' + e[y1]);
						}
					}
				}
				return tops.join(' ');
			}


			underlay.path(smooth(els, 'ymin', 'ymax')).fill(colors[bucket % colors.length])
//			underlay.path(smooth(els, 'ymax')).fill('none').stroke({ width: '2px', color: colors[bucket % colors.length]})
		}
	}, 100)
};
viewModel.startFormatted = ko.computed(function () {
	return moment(viewModel.startDate()).fromNow();
});
viewModel.endFormatted = ko.computed(function () {
	return moment(viewModel.endDate()).fromNow();
});
viewModel.filteredPushes = ko.computed(function() {
	var filter = this.filter();
	if (!filter) {
		return this.pushes();
	} else {
		return ko.utils.arrayFilter(this.pushes(), filter);
	}
}, viewModel);

var underlay;
window.onload = function () {
	underlay = document.getElementById('underlay');
	if (underlay) {
		underlay = SVG(underlay);
	}

	viewModel.view(window.location.href.replace(/.*\/([^/]+)$/, "$1"));
	viewModel.organization(_.first(viewModel.organizations()));
	fetchPushes();
	viewModel.organization.subscribe(fetchPushes);
	viewModel.view.subscribe(function (view) {
		window.location = './' + view;
	});
	ko.applyBindings(viewModel);
};
function fetchPushes() {
	viewModel.loading(true);

	var org = viewModel.organization();
	var url = org == null ? './a/user/pushes' : './a/organization/' + org.login + '/pushes';

	function simpleName(name) {
		if (org && name.indexOf(org.login) === 0) {
			return name.substr(org.login.length + 1);
		}
		return name;
	}

	var bucketEnd;
	var bucketIndex = 0;
	var bucketSizeIndex = 0;
	var bucketSize = [{ minutes: 15 }, { hours: 1 }, { hours: 4 }];
	function bucketer(date) {
		if (bucketEnd == null) {
			bucketEnd = moment(date).clone().startOf('minute');
			bucketEnd.minutes(15 * Math.floor(bucketEnd.minutes()));
			bucketEnd.subtract(bucketSize[0]);
		}
		if (bucketEnd.isBefore(date)) {
			return bucketIndex;
		}
		while (true) {
			bucketSizeIndex++;
			bucketEnd.subtract(bucketSize[Math.floor(bucketSizeIndex / 12)] || { days: 1 })
			if (bucketEnd.isBefore(date)) {
				return bucketIndex++;
			}
		}
	}

	reqwest({
		url: url,
		type: 'json'
	}).then(function (response) {

		var pushes = response.pushes;
		_.each(pushes, function (push) {
			push.bucket = bucketer(push.date);
		});

		var index = 0;
		var repos = _.sortBy(_.map(_.groupBy(pushes, function (push) {
			return push.repo;
		}), function (pushes, repo) {
			return {
				name: repo,
				simpleName: simpleName(repo),
				pushes: pushes,
				color: colors[index++ % colors.length]
			};
		}), function (repo) {
			return repo.name;
		});
		_.each(repos, function (repo) {
			_.each(repo.pushes, function (push) {
				push.repo = repo;
			});
		});
		viewModel.startDate(response.start);
		viewModel.endDate(response.end);
		viewModel.pushes(pushes);
		viewModel.repos(repos);
		viewModel.loading(false);
	}).fail(function (err, msg) {
		console.error(msg);
	});
}
</script>